# 4장. 함수 컴포넌트와 리액트 훅

## 📚 목차

1. 처음 만나는 리액트 훅
2. useMemo와 useCallback 훅 이해하기
3. useState 훅 이해하기
4. useEffect와 useLayoutEffect 훅 이해하기
5. useRef와 useImperativeHandle 훅 이해하기
6. useContext 훅 이해하기

---

### 🔍 처음 만나는 리액트 훅

- #### 리액트 훅이란?

  리액트 훅은 'use'라는 접두사가 이름에 들어가는 일련의 함수입니다.  
  리액트 훅 함수는 반드시 함수 컴포넌트에서만 사용해야 합니다.  
  리액트 훅의 종류는 아래의 표와 같습니다.
  <table>
    <tr>
      <th>용도</th>
      <th>훅</th>
    </tr>
    <tr>
      <td rowspan="4">컴포넌트 데이터 관리</td>
      <td>useMemo</td>
    </tr>
    <tr>
      <td>useCallback</td>
    </tr>
    <tr>
      <td>useState</td>
    </tr>
    <tr>
      <td>useReducer</td>
    </tr>

    <tr>
      <td rowspan="2">컴포넌트 생명 주기 대응</td>
      <td>useEffect</td>
    </tr>
    <tr>
      <td>useLayoutEffect</td>
    </tr>

    <tr>
      <td rowspan="2">컴포넌트 메시지 호출</td>
      <td>useRef</td>
    </tr>
    <tr>
      <td>useImperativeHandle</td>
    </tr>

    <tr>
      <td>컴포넌트 간의 정보 공유</td>
      <td>useContext</td>
    </tr>
  </table>

- #### 리액트 훅 코드 패턴과 의존성 목록

  | 매개변수 개수 | 훅 함수                                                      |
  | :-----------: | ------------------------------------------------------------ |
  |      1개      | useState, useRef, useImperativeHandle, useContext            |
  |      2개      | useMemo, useCallback, useReducer, useEffect, useLayoutEffect |

  - #### 매개변수가 1개인 훅 함수의 코드 패턴

    > 훅\_함수<값의\_타입|null>(값)

    ```javascript
    // useRef 훅 사용 예
    const today: Date = useRef < Date > new Date();
    ```

  - #### 매개변수가 2개인 훅 함수의 코드 패턴

    > 훅\_함수<값의\_타입>(콜백\_함수, 의존성\_목록)

    여기서 의존성 목록은 콜백 함수에서 사용되는 변수나 함수의 값이 일정하지 않고 수시로 변할 수 있을 때, 해당 변수나 함수를 아이템으로 갖는 배열을 의미합니다.  
    의존성 목록에 있는 아이템 중 하나라도 변화가 있으면 콜백 함수를 새로 고침해 변한 값을 콜백 함수에 반영해줍니다.  
    의존성 목록이 빈 배열일 때 콜백 함수는 한 번만 실행됩니다.

    ```javascript
    // useEffect 훅 사용 예
    useEffect(() => {}, []);
    ```

<!-- - #### useEffect 훅 사용하기

  useEffect 훅의 사용법은 다음과 같습니다.
  useEffect는 의존성 목록에 있는 조건 중 어느 하나라도 충족되면 그때마다 콜백 함수를 다시 실행합니다.

  > useEffect(콜백\_함수, 의존성\_목록)
  > 콜백\_함수 = () => {}

  컴포넌트가 생성될 때 한번만 실행하게 하려면 의존성 목록을 []로 만들면 됩니다.
  의존성 목록이 단순히 []일 때 useEffect는 첫 번째 매개변수의 콜백 함수를 한 번만 실행합니다.

  useEffect는 다음처럼 함수를 반환할 수도 있습니다.

  ```javascript
  useEffect(() => {
    //컴포넌트가 생성될 때 실행
    return () => {}; // 컴포넌트가 소멸할 때 한 번 실행
  }, []);
  ```

- #### useRef 훅 사용하기

- #### useState 훅 사용하기

  useState 훅은 다음처럼 사용합니다.
  useState가 반환하는 세터는 현재 값이 변경되면 자동으로 해당 컴포넌트를 다시 렌더링하는 기능이 있습니다.

  > const [현재_값, 세터] = useState(초깃값)
  > 세터 = (새로운\_값) => void -->

- #### 커스텀 훅이란?

  리액트 훅은 여러 훅 함수를 조합해 마치 새로운 훅 함수가 있는 것처럼 만들 수 있는데, 이렇게 조합한 새로운 훅 함수를 커스텀 훅이라고 합니다.  
  커스텀 훅은 리액트 훅뿐만 아니라 기존에 제작한 커스텀 훅 함수를 사용해서 만들 수도 있습니다.  
  커스텀 훅 함수는 '훅'이라는 의미를 강조하고자 함수 이름에 'use'라는 접두어를 붙여서 만듭니다.

- #### 리액트 훅 함수의 특징
  - 같은 리액트 훅을 여러 번 호출할 수 있다.
  - 함수 몸통이 아닌 몸통 안 복합 실행문의 {} 안에서 호출할 수 없다.
  - 비동기 함수를 콜백 함수로 사용할 수 없다.

### 🔍 useMemo와 useCallback 훅 이해하기

- #### 리액트 훅의 기본 원리

  - #### 유효 범위

    모든 프로그래밍 언어에서 변수는 유효한 범위가 있습니다.  
    대부분의 프로그래밍 언어에서는 중괄호 {} 안쪽의 범위를 **블록 범위**라고 하고, 블록 범위 안쪽의 변수를 **지역 변수**라고 합니다. 지역 변수 개념은 함수 몸통에서도 똑같이 적용됩니다.  
    리액트의 함수 컴포넌트 또한 '함수'이므로 몸통에서 변수의 유효 범위는 똑같이 적용됩니다.

  - #### 상태와 캐시

    프로그래밍 분야에서 **상태**란 용어는 변수의 유효 범위와 무관하게 계속 유지하는 값을 의미합니다.  
    상태는 한 번 설정되면 이후로는 값을 변경할 수 없는 '읽기 전용' 개념을 가진 **불변 상태**와 아무 때나 값을 변경할 수 있고 계속 유지하는 **가변 상태**로 나뉩니다.  
    그런데 함수 컴포넌트는 '함수'이므로 블록 범위라는 개념 때문에 상태를 가질 수 없습니다.  
    함수 컴포넌트가 상태를 가질 수 있는 유일한 방법은 상태를 담은 변수를 함수 몸통 바깥으로 꺼내어 블록 범위의 영향을 받지 않게 하는 것입니다. 이처럼 블록 범위 바깥의 변수를 **전역 변수**라고 합니다.  
    리액트 훅은 상태를 가질 수 없는 함수 컴포넌트로 하여금 마치 상태를 가진 것처럼 동작할 수 있게 합니다. 그리고 이런 개념을 이용하면 캐시를 전역 변수 형태로 만들어서 구현할 수 있습니다.  
    **캐시**는 데이터나 값을 미리 복사해 놓는 임시 저장소를 의미합니다. 캐시는 원본 데이터에 접근하는 시간이 오래 걸리거나 값을 다시 계산하는 시간을 절약하고 싶을 때 주로 사용합니다.

  - #### 캐시와 의존성 목록

    리액트 내부에서 관리되는 캐시된 값은 어떤 상황이 일어나면 값을 갱신해 줘야합니다.  
    리액트 훅에서는 캐시를 갱신하게 하는 요소를 **의존성**이라고 합니다. 이러한 의존성으로 구성된 배열을 **의존성 목록**이라고 합니다.  
    리액트는 의존성 목록 중 어느 것 하나라도 조건이 충족되면 캐시된 값을 자동으로 갱신하고 해당 컴포넌트를 다시 렌더링하여 변경 사항을 반영해 줍니다.  
    만일 이런 캐시 갱신이 필요 없다면, 즉 의존성이 없다면 의존성 목록은 빈 배열 []을 사용하면 됩니다.

  - #### 함수 컴포넌트와 리액트 훅을 사용하는 이유

    리액트는 컴포넌트의 속성값이 변할 때 항상 최신 값이 반영되도록 다시 렌더링해 줍니다.  
    그런데 컴포넌트 내부 로직에서 컴포넌트가 다시 렌더링되는 때는 리액트가 탐지하기 어렵습니다. 이 때문에 클래스 기반 컴포넌트는 다양한 메서드를 구현해서 렌더링 여부를 판단할 수 있게 합니다.  
    반면에 함수 컴포넌트에 리액트 훅을 사용하면 리액트 프레임워크가 의존성 목록에서 변한 값이 있는지만 판단하면 되므로 다시 렌더링해야 하는 때를 판단하기가 쉽습니다. 따라서 컴포넌트 개발이 수월해집니다.

- #### 데이터를 캐시하는 useMemo 훅

  useMemo 훅에서 'Memo'는 메모이제이션의 줄임말로, 메모이제이션은 과거에 계산한 값을 반복해서 사용할 때 과거에 계산한 값을 캐시해 두는 방법으로 전체 계산 속도를 높이는 코드 최적화 기법입니다.  
  useMemo 훅을 사용하는 방법은 다음과 같습니다.

  > const 캐시된\_데이터 = useMemo(콜백\_함수, [의존성1, 의존성2, ...])
  > 콜백\_함수 = () => 원본\_데이터

- #### 콜백 함수를 캐시하는 useCallback 훅

  useCallback 훅의 사용 개념은 useMemo와 같으나, useMemo가 데이터를 캐시한다면 useCallback은 콜백 함수를 캐시한다는 차이가 있습니다.  
  useCallback 훅을 사용하는 방법은 다음과 같습니다.

  > const 캐시된\_콜백\_ 함수 = useCallback(원본\_콜백\_함수, 의존성\_목록)

  - #### 고차 함수 사용하기
    함수형 언어에서는 함수와 변수를 차별하지 않으므로 함수는 다른 함수의 입력 매개변수나 반환값으로도 사용될 수 있습니다.  
    **고차 함수**는 다른 함수를 반환하는 함수를 의미합니다.
    리액트에서 고차 함수는 콜백 함수에 어떤 정보를 추가로 전달하려고 할 때 주로 사용합니다.

### 🔍 useState 훅 이해하기

- #### 불변 상태를 캐시하는 useState 훅

  useMemo 훅은 불변 상태를 캐시하지만, useState 훅은 가변 상태를 캐시합니다.  
  useState 훅 사용법은 다음과 같습니다.
  useState 훅이 반환한 세터 함수는 리액트가 컴포넌트 내부의 상태 변화를 쉽게 감지할 수 있게 해줍니다.  
  즉, 리액트는 세터 함수가 호출되면 컴포넌트의 상태에 변화가 있는 것으로 판단하고 즉시 해당 컴포넌트를 다시 렌더링합니다.

  > const [값, 값을\_변경하는\_세터\_함수] = useState(초깃값)

  <!-- useState 훅은 컴포넌트가 자신만의 상태를 유지하려고 할 때 사용하는 중요한 함수입니다. -->
