# 4장. 함수 컴포넌트와 리액트 훅

## 📚 목차

1. 처음 만나는 리액트 훅
2. useMemo와 useCallback 훅 이해하기
3. useState 훅 이해하기
4. useEffect와 useLayoutEffect 훅 이해하기
5. useRef와 useImperativeHandle 훅 이해하기
6. useContext 훅 이해하기

---

### 🔍 처음 만나는 리액트 훅

- #### 리액트 훅이란?

  리액트 훅은 'use'라는 접두사가 이름에 들어가는 일련의 함수입니다.  
  리액트 훅 함수는 반드시 함수 컴포넌트에서만 사용해야 합니다.  
  리액트 훅의 종류는 아래의 표와 같습니다.
  <table>
    <tr>
      <th>용도</th>
      <th>훅</th>
    </tr>
    <tr>
      <td rowspan="4">컴포넌트 데이터 관리</td>
      <td>useMemo</td>
    </tr>
    <tr>
      <td>useCallback</td>
    </tr>
    <tr>
      <td>useState</td>
    </tr>
    <tr>
      <td>useReducer</td>
    </tr>

    <tr>
      <td rowspan="2">컴포넌트 생명 주기 대응</td>
      <td>useEffect</td>
    </tr>
    <tr>
      <td>useLayoutEffect</td>
    </tr>

    <tr>
      <td rowspan="2">컴포넌트 메시지 호출</td>
      <td>useRef</td>
    </tr>
    <tr>
      <td>useImperativeHandle</td>
    </tr>

    <tr>
      <td>컴포넌트 간의 정보 공유</td>
      <td>useContext</td>
    </tr>
  </table>

- #### 리액트 훅 코드 패턴과 의존성 목록

  | 매개변수 개수 | 훅 함수                                                      |
  | :-----------: | ------------------------------------------------------------ |
  |      1개      | useState, useRef, useImperativeHandle, useContext            |
  |      2개      | useMemo, useCallback, useReducer, useEffect, useLayoutEffect |

  - #### 매개변수가 1개인 훅 함수의 코드 패턴

    > 훅\_함수<값의\_타입|null>(값)

    ```javascript
    // useRef 훅 사용 예
    const today: Date = useRef < Date > new Date();
    ```

  - #### 매개변수가 2개인 훅 함수의 코드 패턴

    > 훅\_함수<값의\_타입>(콜백\_함수, 의존성\_목록)

    여기서 의존성 목록은 콜백 함수에서 사용되는 변수나 함수의 값이 일정하지 않고 수시로 변할 수 있을 때, 해당 변수나 함수를 아이템으로 갖는 배열을 의미합니다.  
    의존성 목록에 있는 아이템 중 하나라도 변화가 있으면 콜백 함수를 새로 고침해 변한 값을 콜백 함수에 반영해줍니다.  
    의존성 목록이 빈 배열일 때 콜백 함수는 한 번만 실행됩니다.

    ```javascript
    // useEffect 훅 사용 예
    useEffect(() => {}, []);
    ```

<!-- - #### useEffect 훅 사용하기

  useEffect 훅의 사용법은 다음과 같습니다.
  useEffect는 의존성 목록에 있는 조건 중 어느 하나라도 충족되면 그때마다 콜백 함수를 다시 실행합니다.

  > useEffect(콜백\_함수, 의존성\_목록)
  > 콜백\_함수 = () => {}

  컴포넌트가 생성될 때 한번만 실행하게 하려면 의존성 목록을 []로 만들면 됩니다.
  의존성 목록이 단순히 []일 때 useEffect는 첫 번째 매개변수의 콜백 함수를 한 번만 실행합니다.

  useEffect는 다음처럼 함수를 반환할 수도 있습니다.

  ```javascript
  useEffect(() => {
    //컴포넌트가 생성될 때 실행
    return () => {}; // 컴포넌트가 소멸할 때 한 번 실행
  }, []);
  ```

- #### useRef 훅 사용하기

- #### useState 훅 사용하기

  useState 훅은 다음처럼 사용합니다.
  useState가 반환하는 세터는 현재 값이 변경되면 자동으로 해당 컴포넌트를 다시 렌더링하는 기능이 있습니다.

  > const [현재_값, 세터] = useState(초깃값)
  > 세터 = (새로운\_값) => void -->

- #### 커스텀 훅이란?

  리액트 훅은 여러 훅 함수를 조합해 마치 새로운 훅 함수가 있는 것처럼 만들 수 있는데, 이렇게 조합한 새로운 훅 함수를 커스텀 훅이라고 합니다.  
  커스텀 훅은 리액트 훅뿐만 아니라 기존에 제작한 커스텀 훅 함수를 사용해서 만들 수도 있습니다.  
  커스텀 훅 함수는 '훅'이라는 의미를 강조하고자 함수 이름에 'use'라는 접두어를 붙여서 만듭니다.

- #### 리액트 훅 함수의 특징
  - 같은 리액트 훅을 여러 번 호출할 수 있다.
  - 함수 몸통이 아닌 몸통 안 복합 실행문의 {} 안에서 호출할 수 없다.
  - 비동기 함수를 콜백 함수로 사용할 수 없다.

### 🔍 useMemo와 useCallback 훅 이해하기

- #### 리액트 훅의 기본 원리

  - #### 유효 범위

    모든 프로그래밍 언어에서 변수는 유효한 범위가 있습니다.  
    대부분의 프로그래밍 언어에서는 중괄호 {} 안쪽의 범위를 **블록 범위**라고 하고, 블록 범위 안쪽의 변수를 **지역 변수**라고 합니다. 지역 변수 개념은 함수 몸통에서도 똑같이 적용됩니다.  
    리액트의 함수 컴포넌트 또한 '함수'이므로 몸통에서 변수의 유효 범위는 똑같이 적용됩니다.

  - #### 상태와 캐시

    프로그래밍 분야에서 **상태**란 용어는 변수의 유효 범위와 무관하게 계속 유지하는 값을 의미합니다.  
    상태는 한 번 설정되면 이후로는 값을 변경할 수 없는 '읽기 전용' 개념을 가진 **불변 상태**와 아무 때나 값을 변경할 수 있고 계속 유지하는 **가변 상태**로 나뉩니다.  
    그런데 함수 컴포넌트는 '함수'이므로 블록 범위라는 개념 때문에 상태를 가질 수 없습니다.  
    함수 컴포넌트가 상태를 가질 수 있는 유일한 방법은 상태를 담은 변수를 함수 몸통 바깥으로 꺼내어 블록 범위의 영향을 받지 않게 하는 것입니다. 이처럼 블록 범위 바깥의 변수를 **전역 변수**라고 합니다.  
    리액트 훅은 상태를 가질 수 없는 함수 컴포넌트로 하여금 마치 상태를 가진 것처럼 동작할 수 있게 합니다. 그리고 이런 개념을 이용하면 캐시를 전역 변수 형태로 만들어서 구현할 수 있습니다.  
    **캐시**는 데이터나 값을 미리 복사해 놓는 임시 저장소를 의미합니다. 캐시는 원본 데이터에 접근하는 시간이 오래 걸리거나 값을 다시 계산하는 시간을 절약하고 싶을 때 주로 사용합니다.

  - #### 캐시와 의존성 목록

    리액트 내부에서 관리되는 캐시된 값은 어떤 상황이 일어나면 값을 갱신해 줘야합니다.  
    리액트 훅에서는 캐시를 갱신하게 하는 요소를 **의존성**이라고 합니다. 이러한 의존성으로 구성된 배열을 **의존성 목록**이라고 합니다.  
    리액트는 의존성 목록 중 어느 것 하나라도 조건이 충족되면 캐시된 값을 자동으로 갱신하고 해당 컴포넌트를 다시 렌더링하여 변경 사항을 반영해 줍니다.  
    만일 이런 캐시 갱신이 필요 없다면, 즉 의존성이 없다면 의존성 목록은 빈 배열 []을 사용하면 됩니다.

  - #### 함수 컴포넌트와 리액트 훅을 사용하는 이유

    리액트는 컴포넌트의 속성값이 변할 때 항상 최신 값이 반영되도록 다시 렌더링해 줍니다.  
    그런데 컴포넌트 내부 로직에서 컴포넌트가 다시 렌더링되는 때는 리액트가 탐지하기 어렵습니다. 이 때문에 클래스 기반 컴포넌트는 다양한 메서드를 구현해서 렌더링 여부를 판단할 수 있게 합니다.  
    반면에 함수 컴포넌트에 리액트 훅을 사용하면 리액트 프레임워크가 의존성 목록에서 변한 값이 있는지만 판단하면 되므로 다시 렌더링해야 하는 때를 판단하기가 쉽습니다. 따라서 컴포넌트 개발이 수월해집니다.

- #### 데이터를 캐시하는 useMemo 훅

  useMemo 훅에서 'Memo'는 메모이제이션의 줄임말로, 메모이제이션은 과거에 계산한 값을 반복해서 사용할 때 과거에 계산한 값을 캐시해 두는 방법으로 전체 계산 속도를 높이는 코드 최적화 기법입니다.  
  useMemo 훅을 사용하는 방법은 다음과 같습니다.

  > const 캐시된\_데이터 = useMemo(콜백\_함수, [의존성1, 의존성2, ...])
  > 콜백\_함수 = () => 원본\_데이터

- #### 콜백 함수를 캐시하는 useCallback 훅

  useCallback 훅의 사용 개념은 useMemo와 같으나, useMemo가 데이터를 캐시한다면 useCallback은 콜백 함수를 캐시한다는 차이가 있습니다.  
  useCallback 훅을 사용하는 방법은 다음과 같습니다.

  > const 캐시된\_콜백\_ 함수 = useCallback(원본\_콜백\_함수, 의존성\_목록)

  - #### 고차 함수 사용하기
    함수형 언어에서는 함수와 변수를 차별하지 않으므로 함수는 다른 함수의 입력 매개변수나 반환값으로도 사용될 수 있습니다.  
    **고차 함수**는 다른 함수를 반환하는 함수를 의미합니다.
    리액트에서 고차 함수는 콜백 함수에 어떤 정보를 추가로 전달하려고 할 때 주로 사용합니다.

### 🔍 useState 훅 이해하기

- #### 가변 상태를 캐시하는 useState 훅

  useMemo 훅은 불변 상태를 캐시하지만, useState 훅은 가변 상태를 캐시합니다.  
  useState 훅 사용법은 다음과 같습니다.
  useState 훅이 반환한 세터 함수는 리액트가 컴포넌트 내부의 상태 변화를 쉽게 감지할 수 있게 해줍니다.  
  즉, 리액트는 세터 함수가 호출되면 컴포넌트의 상태에 변화가 있는 것으로 판단하고 즉시 해당 컴포넌트를 다시 렌더링합니다.

  > const [값, 값을\_변경하는\_세터\_함수] = useState(초깃값)

  useState 훅은 컴포넌트가 자신만의 상태를 유지하려고 할 때 사용하는 중요한 함수입니다.

  - #### 깊은 복사와 얕은 복사, 그리고 의존성 목록

    대다수 프로그래밍 언어에서 어떤 변수에 담긴 값을 다른 변수에 복사할 때는 **깊은 복사**와 **얕은 복사**라는 2가지 방식을 지원합니다.  
    복사 방식은 값의 타입에 따라 각기 다르게 적용됩니다. 메모리 크기를 컴파일 타임 때 알 수 있는 타입(number, boolean 등)은 항상 깊은 복사가 일어납니다. 반면에 메모리 크기를 런타임 때 알 수 있는 타입(객체, 배열 등)은 얕은 복사가 일어납니다.  
    한 가지 예외 상황은 string 타입 문자열인데, 타입스크립트에서 문자열은 항상 읽기 전용이므로 메모리 크기를 컴파일 타임 때 알 수 있습니다. 따라서 문자열은 깊은 복사가 일어납니다.

  - #### 객체에 적용하는 타입스크립트 전개 연산자 구문

    다음은 전개 연산자를 사용해 두 객체를 병합하는 예입니다.

    ```javascript
    let coord = { ...{ x: 0 }, ...{ y: 0 } };
    console.log(coord); // {x: 0, y:0 }
    ```

    전개 연산자는 배열에도 적용할 수 있으며, 깊은 복사를 일으킵니다.

  - #### 타입스크립트 객체 반환 구문
    타입스크립트에서 객체를 반환하는 구문은 객체를 의미하는 중괄호 {}를 다시 소괄호로 감싼 ({}) 형태로 사용해야 합니다.  
    이는 복합 실행문은 소괄호로 감쌀 수 없다는 특성을 활용한 것입니다.

### 🔍 useEffect와 useLayoutEffect 훅 이해하기

- #### 컴포넌트의 생명 주기란?

  리액트는 컴포넌트를 생성하고 렌더링하다가 어떤 시점이 되면 소멸합니다. 이러한 과정을 컴포넌트의 **생명 주기**라고 표현합니다.

  - #### 컴포넌트 마운트

    리액트 컴포넌트는 가상 DOM 객체 형태로 생성되어 어떤 시점에 물리 DOM 트리의 멤버 객체가 되며, 이 과정에서 처음 렌더링이 일어나는데 이 시점을 컴포넌트가 **마운트**되었다고 표현합니다. 즉, 가상 DOM 객체가 물리 DOM 객체로 바뀌는 시점을 마운트되었다고 표현합니다.

  - #### 컴포넌트 언마운트
    컴포넌트가 생성되고 마운트되어 웹 페이지에 나타난 후 어떤 시점이 되면 컴포넌트는 소멸합니다. 리액트에서는 컴포넌트가 물리 DOM 객체로 있다가 소멸하는 것을 **언마운트**되었다고 표현합니다.

- #### useEffect와 useLayoutEffect 훅 알아보기

  useEffect와 useLayoutEffect 훅은 다음처럼 사용법이 같으며 콜백 함수는 훅이 실행될 때 처음 한 번은 반드시 실행됩니다. 이런 특징 때문에 의존성 목록이 빈 배열 []일지라도 한 번은 콜백 함수를 호출합니다.  
  두 훅의 콜백 함수는 함수를 반환할 수도 있는데, 이 때 반환 함수는 컴포넌트가 언마운트될 때 한 번만 호출됩니다.

  > useEffect(콜백\_함수, 의존성\_목록)
  > useLayoutEffect(콜백\_함수, 의존성\_목록)
  > 콜백\_함수 = () => {} 또는 콜백\_함수 = () => { return 반환\_함수}

  - #### useLayoutEffect와 useEffect 훅의 차이점

    리액트는 useLayoutEffect 훅은 동기로 실행하고, useEffect 훅은 비동기로 실행합니다. 이 말은 useLayoutEffect 훅은 콜백 함수가 끝날 때까지 프레임워크가 기다린다는 의미입니다. 반면에 useEffect는 콜백 함수의 종료를 기다리지 않습니다.  
    리액트 공식 문서에서는 될 수 있으면 useEffect 훅을 사용하라고 권합니다.

  - #### fetch() 함수와 Promise 클래스 고찰해 보기
    fetch() 함수는 HTTP 메서드를 프로그래밍으로 쉽게 사용하게 해줍니다. fetch는 Response 타입 객체를 Promise 방식으로 얻을 수 있게 해줍니다.
    Promise 클래스는 비동기 콜백 함수를 쉽게 구현하려고 만든 것으로, then(), catch(), finally() 메서드를 제공합니다. 다음은 Promise의 3가지 메서드를 사용한 예입니다.
    ```javascript
    fetch("https://randomuser.me/api/")
      .then((res) => res.json())
      .then((data: unknown) => console.log(data))
      .catch((error: Error) => console.log(err.message))
      .finally(() => console.log("always called"));
    ```
    - then() 메서드는 모든 게 정상일 때 설정된 콜백 함수를 호출합니다. 만일 then() 메서드의 콜백 함수가 값이나 또 다른 Promise 객체를 반환할 때는 then() 메서드를 다시 호출해 콜백 함수가 반환한 값을 얻을 수 있습니다.
    - catch() 메서드는 오류가 발생할 때 자바스크립트 엔진이 기본으로 제공하는 Error 타입의 값을 콜백 함수의 입력 매개변수로 전달해 호출해 줍니다.
    - finally() 메서드는 then()이나 catch()의 콜백 함수가 호출된 다음, 항상 자신에 설정된 콜백 함수를 호출해 줍니다.

### 🔍 useRef와 useImperativeHandle 훅 이해하기

- #### ref 속성이란?
  모든 리액트 컴포넌트는 reference의 앞 3글자를 딴 ref 속성을 제공합니다.그런데 ref 속성값은 사용자 코드에서 설정하는 것이 아니라 어떤 시점에 리액트 내부에서 설정해 줍니다.  
  ref 속성은 초기에는 null이었다가 마운트되는 시점에서 물리 DOM 객체의 값이 됩니다. 즉, ref는 물리 DOM 객체의 참조입니다.

### 🔍 useContext 훅 이해하기

- #### 컨텍스트란?

  컴포넌트의 속성은 부모 컴포넌트가 자식 컴포넌트로 어떤 정보를 전달하려고 할 때 사용하는 메커니즘입니다. 그런데 부모 컴포넌트가 직계 자식이 아닌, 손자나 증손자 컴포넌트에 정보를 전달하려고 하면 번거로워집니다.
  리액트는 이런 속성 전달의 번거로움을 해소하고자 **컨텍스트**라는 메커니즘을 구현해놓았습니다.  
  리액트에서 컨텍스트는 createContext와 useContext 훅으로 이뤄지며, 부모 컴포넌트에서 createContext를 통해 공유할 정보를 설정하면 자식 컴포넌트나 손자 컴포넌트에서는 useContext 훅을 통해 공유 정보를 취득할 수 있습니다.  
  모든 컨텍스트 제공자는 가장 최상위 컴포넌트로 동작해야 합니다.  
  컨텍스트는 최상위 부모 컴포넌트가 컨텍스트 제공자 컴포넌트를 통해 제공하는 기능을 자식뿐만 아니라 자손 컴포넌트들도 useContext 훅으로 사용할 수 있게 하는 기능입니다.

  - #### 컨텍스트 객체가 제공하는 Provider 컴포넌트
    createContext 함수 호출로 생성된 컨텍스트 객체는 Provider와 Consumer라는 컴포넌트를 제공합니다.  
    여기서 Provider는 컨텍스트의 기능을 제공할 컴포넌트이고, Consumer는 Provider가 제공한 기능을 사용하고 싶은 클래스 컴포넌트입니다.  
    그런데 함수 컴포넌트는 클래스 컴포넌트와 달리 Consumer보다 훨씬 사용법이 단순한 useContext 훅을 사용하면 됩니다.  
    Provider 컴포넌트는 value와 children 속성이 있는 ProviderProps 속성을 제공합니다. value 속성에 설정하는 값이 Provider 컨텍스트가 제공하는 기능이 됩니다.

- #### useContext 훅 알아보기
  useContext 훅은 컨텍스트 객체가 제공하는 Provider 컴포넌트의 value 속성값을 얻을 수 있게 하는 목적으로 사용되는 훅입니다.
